<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AR.js Example</title>
    <link rel="stylesheet" href="ar.css">
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<body>
<div class="ui--overlay">
    <button class="ui--button ui-button--home"><a class="ui--button--link" href="/"><i class="bi bi-house-fill"></i></a></button>
    <button class="ui--button">Toggle Info</button>
    <div id="infoText" style="display: none; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px;">
        Scan a marker to see objects!
    </div>
</div>

<!--point of rendering camera and other events-->
<a-scene
        embedded
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
        zoom-controls
>
<!--    markers that can be detected-->
    <a-marker id="reception" preset="custom" type="pattern" url="tags/patt/20.patt">
    </a-marker>

    <a-marker id="library" preset="custom" type="pattern" url="tags/patt/1.patt">
    </a-marker>

    <a-marker id="cafeteria" preset="custom" type="pattern" url="tags/patt/2.patt">
    </a-marker>

<!--    more can be added soon -->

<!--    rendering camera -->
    <a-entity camera></a-entity>
</a-scene>

<script type="module">
<!--    constants  for locations of the map and pointer -->
    const RECEPTION_PIP_LOCATION = {x: -1.5, y: 0.1, z: 2};
    const LIBRARY_PIP_LOCATION = {x: 0, y: 0.1, z: 0};
    const CAFETERIA_PIP_LOCATION = {x: 2, y: 0.1, z: 1};

    const RECEPTION_LOCATION = {x: 0, y: 0, z: 0};
    const LIBRARY_LOCATION = {x: 10, y: 0, z: 0};
    const CAFETERIA_LOCATION = {x: 8, y: 0, z: 0};

    const PIP_ROTATION = {x: -Math.PI / 2, y: 0, z: 0};

    // zoom functionality for the objects
    AFRAME.registerComponent('zoom-controls', {
        init: function () {
            this.camera = this.el.sceneEl.camera;
            this.zoomLevel = 1;
            this.minZoom = 0.5;
            this.maxZoom = 2;

            // controls for the mouse
            window.addEventListener('wheel', (event) => {
                event.preventDefault();
                this.adjustZoom(event.deltaY > 0 ? -0.1 : 0.1);
            });

            let lastDistance = null;

            // controls for the touch screen
            window.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2) {
                    event.preventDefault();
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const distance = Math.hypot(touch1.pageX - touch2.pageX, touch1.pageY - touch2.pageY);
                    if (lastDistance) {
                        this.adjustZoom((distance - lastDistance) * 0.005);
                    }
                    lastDistance = distance;
                }
            });
            window.addEventListener('touchend', () => lastDistance = null);
        },
        adjustZoom: function (delta) {
            this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel + delta));
            if (this.camera) {
                this.camera.zoom = this.zoomLevel;
                this.camera.updateProjectionMatrix();
            }
        }
    });

    // marker objects
    const reception = document.querySelector('#reception');
    const library = document.querySelector('#library');
    const cafeteria = document.querySelector('#cafeteria');
    let plane, pipObject;

    // loading objects on the marker
    function loadObjects(marker, floor, map_position, pip_position) {
        if (plane || pipObject) return;

        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(floor, function(texture) {
            const geometry = new THREE.PlaneGeometry(10, 5);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            plane = new THREE.Mesh(geometry, material);
            plane.position.set(map_position.x, map_position.y, map_position.z);
            plane.scale.set(2.5, 2.5, 2.5);
            plane.rotation.x = -Math.PI / 2;
            marker.object3D.add(plane);
        });

        const mtlLoader = new THREE.MTLLoader();
        mtlLoader.load('OBJ/Pip_stand.mtl', function (materials) {
            materials.preload();
            const objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.load('OBJ/Pip_stand.obj', function (object) {
                pipObject = object;
                object.scale.set(0.1, 0.1, 0.1);
                object.rotation.set(PIP_ROTATION.x, PIP_ROTATION.y, PIP_ROTATION.z);
                object.position.set(pip_position.x, pip_position.y, pip_position.z);
                marker.object3D.add(object);
            });
        });
    }

    // removing objects when no marker is detected
    function removeObjects(marker) {
        if (plane) {
            marker.object3D.remove(plane);
            plane = null;
        }
        if (pipObject) {
            marker.object3D.remove(pipObject);
            pipObject = null;
        }
    }

    // event listeners for the detection of the marker
    reception.addEventListener('markerFound', () => {
        loadObjects(reception, 'FLOOR_G.png', RECEPTION_LOCATION, RECEPTION_PIP_LOCATION);
    });

    library.addEventListener('markerFound', () => {
        loadObjects(library, 'FLOOR_1.png', LIBRARY_LOCATION, LIBRARY_PIP_LOCATION);
    });

    cafeteria.addEventListener('markerFound', () => {
        loadObjects(cafeteria, 'FLOOR_G.png', CAFETERIA_LOCATION, CAFETERIA_PIP_LOCATION);
    });

    // removing objects
    if (!cafeteria.object3D.visible) {
        removeObjects(cafeteria);
    }

    if (!reception.object3D.visible) {
        removeObjects(reception);
    }
    if (!library.object3D.visible) {
        removeObjects(library);
    }
</script>
</body>
</html>