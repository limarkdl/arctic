<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AR.js Example</title>
    <link rel="stylesheet" href="ar.css">
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<body>
<div class="ui--overlay">
    <button class="ui--button ui-button--home"><a class="ui--button--link" href="/"><i class="bi bi-house-fill"></i></a></button>
</div>

<a-scene
        embedded
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
        zoom-controls
>
    <a-marker id="reception" preset="custom" type="pattern" url="tags/patt/20.patt"></a-marker>
    <a-marker id="library" preset="custom" type="pattern" url="tags/patt/1.patt"></a-marker>
    <a-marker id="cafeteria" preset="custom" type="pattern" url="tags/patt/2.patt"></a-marker>
    <a-entity camera></a-entity>
</a-scene>

<script type="module">
    const RECEPTION_PIP_LOCATION = {x: -1.5, y: 0.1, z: 2};
    const LIBRARY_PIP_LOCATION = {x: 0, y: 0.1, z: 0};
    const CAFETERIA_PIP_LOCATION = {x: 2, y: 0.1, z: 1};
    const RECEPTION_LOCATION = {x: 0, y: 0, z: 0};
    const LIBRARY_LOCATION = {x: 10, y: 0, z: 0};
    const CAFETERIA_LOCATION = {x: 8, y: 0, z: 0};
    const PIP_ROTATION = {x: -Math.PI / 2, y: 0, z: 0};

    AFRAME.registerComponent('zoom-controls', {
        init: function () {
            this.camera = this.el.sceneEl.camera;
            this.zoomLevel = 1;
            this.minZoom = 0.5;
            this.maxZoom = 2;
            window.addEventListener('wheel', (event) => {
                event.preventDefault();
                this.adjustZoom(event.deltaY > 0 ? -0.1 : 0.1);
            });
            let lastDistance = null;
            window.addEventListener('touchmove', (event) => {
                if (event.touches.length === 2) {
                    event.preventDefault();
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const distance = Math.hypot(touch1.pageX - touch2.pageX, touch1.pageY - touch2.pageY);
                    if (lastDistance) {
                        this.adjustZoom((distance - lastDistance) * 0.005);
                    }
                    lastDistance = distance;
                }
            });
            window.addEventListener('touchend', () => lastDistance = null);
        },
        adjustZoom: function (delta) {
            this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel + delta));
            if (this.camera) {
                this.camera.zoom = this.zoomLevel;
                this.camera.updateProjectionMatrix();
            }
        }
    });

    const reception = document.querySelector('#reception');
    const library = document.querySelector('#library');
    const cafeteria = document.querySelector('#cafeteria');

    // Store objects per marker to allow multiple instances
    const markerObjects = new Map();

    function loadObjects(marker, floor, map_position, pip_position) {
        if (markerObjects.has(marker)) return; // Already loaded for this marker

        const objects = { plane: null, pip: null };
        markerObjects.set(marker, objects);

        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            floor,
            function(texture) {
                const geometry = new THREE.PlaneGeometry(10, 5);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                objects.plane = new THREE.Mesh(geometry, material);
                objects.plane.position.set(map_position.x, map_position.y, map_position.z);
                objects.plane.scale.set(2.5, 2.5, 2.5);
                objects.plane.rotation.x = -Math.PI / 2;
                marker.object3D.add(objects.plane);
                console.log(`${marker.id}: Plane loaded`);
            },
            undefined,
            function(error) {
                console.error(`${marker.id}: Error loading texture ${floor}`, error);
            }
        );

        const mtlLoader = new THREE.MTLLoader();
        mtlLoader.load(
            'OBJ/Pip_stand.mtl',
            function(materials) {
                materials.preload();
                const objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.load(
                    'OBJ/Pip_stand.obj',
                    function(object) {
                        objects.pip = object;
                        object.scale.set(0.1, 0.1, 0.1);
                        object.rotation.set(PIP_ROTATION.x, PIP_ROTATION.y, PIP_ROTATION.z);
                        object.position.set(pip_position.x, pip_position.y, pip_position.z);
                        marker.object3D.add(object);
                        console.log(`${marker.id}: Pip loaded`);
                    },
                    undefined,
                    function(error) {
                        console.error(`${marker.id}: Error loading Pip object`, error);
                    }
                );
            },
            undefined,
            function(error) {
                console.error(`${marker.id}: Error loading Pip materials`, error);
            }
        );
    }

    function removeObjects(marker) {
        const objects = markerObjects.get(marker);
        if (!objects) return;

        if (objects.plane) {
            marker.object3D.remove(objects.plane);
            console.log(`${marker.id}: Plane removed`);
        }
        if (objects.pip) {
            marker.object3D.remove(objects.pip);
            console.log(`${marker.id}: Pip removed`);
        }
        markerObjects.delete(marker);
    }

    reception.addEventListener('markerFound', () => {
        console.log('Reception marker detected');
        loadObjects(reception, 'FLOOR_G.png', RECEPTION_LOCATION, RECEPTION_PIP_LOCATION);
    });
    library.addEventListener('markerFound', () => {
        console.log('Library marker detected');
        loadObjects(library, 'FLOOR_1.png', LIBRARY_LOCATION, LIBRARY_PIP_LOCATION);
    });
    cafeteria.addEventListener('markerFound', () => {
        console.log('Cafeteria marker detected');
        loadObjects(cafeteria, 'FLOOR_G.png', CAFETERIA_LOCATION, CAFETERIA_PIP_LOCATION);
    });

    reception.addEventListener('markerLost', () => {
        console.log('Reception marker lost');
        removeObjects(reception);
    });
    library.addEventListener('markerLost', () => {
        console.log('Library marker lost');
        removeObjects(library);
    });
    cafeteria.addEventListener('markerLost', () => {
        console.log('Cafeteria marker lost');
        removeObjects(cafeteria);
    });
</script>
</body>
</html>